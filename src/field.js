var helper = require('./helper');
var _ = require('lodash');

function Field(name, options) {
    this.$name = name;
    this.$options = options;
}
//<editor-fold desc="static isField">
Field.isField = function (object) {
    if (object && object.$typeName && object.super_ === Field && _.isFunction(object)) {
        return true;
    }
    return false;
}
//</editor-fold>

helper.mixin(Field.prototype, ['name', 'dbName', 'options'])
helper.mixin(Field.prototype, ['isPrimaryKey', 'isUnique', 'isRequired', 'defaultValue', 'autoGenerated', 'isIndexed', 'isLazy', 'isVirtual'])


//<editor-fold desc="db init create">
Field.prototype.create = function (table, dbName) {
    throw new Error('override this method');
}
Field.prototype.$create = function (table) {
    var fb = this.create(table, this.dbName());
    if (this.isPrimaryKey()) {
        fb.primary().notNullable();
    }
    else {
        if (this.isUnique()) fb.unique()
        if (this.isRequired()) fb.notNullable()
        else fb.nullable()

        if(this.hasDBDefaultValue()){
            var dv = this.defaultValue();
            if (dv) {
                fb.defaultTo(this.dbCast(dv))
            }
        }


        var index = this.isIndexed();

        if (index) {
            fb.index()
        }
    }


}
//</editor-fold>
Field.prototype.hasDBDefaultValue = function () {

    return true;
}
Field.prototype.hasDefaultValue = function () {
    var opt = this.options();
    return 'defaultValue' in opt || 'default' in opt;
}
Field.prototype.cast = function (v, model) {
    return v
}
Field.prototype.dbCast = function (v, model) {
    return v
}
Field.prototype.where = function (query, val, model) {

    query.where(this.name(), val);
    return query
}

var roles = [{
    field: 'id',
    validator: 'range',
    params: [5, 10]
}, {
    field: 't',
    validator: function (value, model, params) {
        return value ? true : false
    },
    message: ' heh ok {0}'
}];

Field.prototype.validators = function (group) {
    var self = this, opt = this.options();


    function parse(data) {
        var d = data.split(':');
        var r = {
            validator: d[0]
        }
        if (d.length > 1) {
            r.params = d.slice(1)
        }

        return r;
    }

    return _.filter(opt.validation, function (it) {
        if (_.isObject(it)) {
            if (group) {
                if (it.group) {

                    var gg = Array.isArray(it.group) ? it.group : [it.group]
                    return gg.indexOf(group) > -1
                }
            }
        }
        return true
    }).map(function (it) {
        if (_.isString(it)) {
            var d = parse(it);
            return {validator: d.validator, params: d.params}
        }
        if (_.isFunction(it)) {
            return {
                validator: it
            }
        }

        if (_.isObject(it)) {
            if (_.isString(it.validator)) {
                var d = parse(it.validator);
                return {
                    validator: d.validator,
                    params: (d.params || []).concat(it.params || []),
                    message: it.message
                }
            }
            if (_.isFunction(it.validator)) {

                return {
                    validator: it.validator,
                    params: it.params,
                    message: it.message
                }
            }
        }

        throw new Error('not supported validation options')
    })
        .map(function (it) {
            it.field = self.name()
            return it
        })
}
Field.prototype.validators1 = function (group) {
    var opt = this.options();


    function parse(data) {
        var d = data.split(':');
        var r = {
            validator: d[0]
        }
        if (d.length > 1) {
            r.params = d.slice(1)
        }

        return r;
    }

    return _.filter(opt.validation, function (it) {
        if (_.isObject(it)) {
            if (group) {
                if (it.group) {

                    _.union()

                    var gg = Array.isArray(it.group) ? it.group : [it.group]
                    return gg.indexOf(group) > -1
                }
            }
        }
        return true
    }).map(function (it) {
        if (_.isString(it)) {
            var d = parse(it);
            return {validator: d.validator, params: d.params}
        }
        if (_.isFunction(it)) {
            return {
                validator: it
            }
        }

        if (_.isObject(it)) {
            if (_.isString(it.validator)) {
                var d = parse(it.validator);
                return {
                    validator: d.validator,
                    params: (d.params || []).concat(it.params || []),
                    message: it.message
                }
            }
            if (_.isFunction(it.validator)) {

                return {
                    validator: it.validator,
                    params: it.params,
                    message: it.message
                }
            }
        }

        throw new Error('not supported validation options')
    })
}


module.exports = Field;